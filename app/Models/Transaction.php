<?php

namespace App\Models;

use Carbon\Carbon;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;

class Transaction extends Model
{
    use HasFactory;
    use SoftDeletes;

    protected $fillable = ['type', 'transaction_date', 'income_category_id', 'expense_root_category_id', 'expense_secondary_category_id', 'expense_final_category_id', 'title', 'price', 'quantity', 'company'];

    protected $casts = [
        'transaction_date' => 'datetime'   // date | datetime | timestamp
    ];

    public static function boot()
    {
        parent::boot(); // TODO: Change the autogenerated stub

        self::creating(function ($model) {
            $model->user_id = auth()->id();
            if (!$model->quantity) {
                $model->quantity = 1;
            }
            $model->amount = $model->price * $model->quantity;
            if (!$model->title) {
                switch ($model->type) {
                    case "income":
                        $category = IncomeCategory::find($model->income_category_id);
                        $model->title = $category->title;
                        break;
                    default:
                        $model->title = "Unkhonwn";
                        break;
                }
            }
            if (!$model->transaction_date) {
                $model->transaction_date = Carbon::now();
            }
        });

        self::updating(function ($model) {
            $model->amount = $model->price * $model->quantity;
        });

        self::created(function (Transaction $model) {
            $account = $model->user()->first();
            if ($account) {
                switch ($model->type) {
                    case "income":
                        $account->updateBalance(0, $model->amount);
                        break;
                    case "expense":
                        $account->updateBalance($model->amount, 0);
                        $model->distribute();
                        break;
                }
            }
        });

        self::updated(function (Transaction $model) {
            $account = $model->user()->first();
            if ($account) {
                $account->updateBalance($model->getOriginal('amount') ?: 0, $model->amount);
            }
        });

        self::deleted(function (Transaction $model) {
            $account = $model->user()->first();
            if ($account) {
                switch ($model->type) {
                    case "income":
                        $account->updateBalance($model->amount, 0);
                        break;
                    case "expense":
                        $account->updateBalance(0, $model->amount);
                        break;
                }
            }

            if ($billId = $model->bill_id) {
                if (Transaction::where("bill_id", $billId)->count() === 0) {
                    Bill::where("id", $billId)->delete();
                }
            }
        });
    }

    public function user()
    {
        return $this->belongsTo(User::class);
    }

    public function incomeCategory()
    {
        return $this->belongsTo(IncomeCategory::class);
    }

    public function expenseRootCategory()
    {
        return $this->belongsTo(ExpenseCategory::class, 'expense_root_category_id');
    }

    public function expenseSecondaryCategory()
    {
        return $this->belongsTo(ExpenseCategory::class, 'expense_secondary_category_id');
    }

    public function expenseFinalCategory()
    {
        return $this->belongsTo(ExpenseCategory::class, 'expense_final_category_id');
    }

    public function bill()
    {
        return $this->belongsTo(Bill::class);
    }

    public function product()
    {
        return $this->belongsTo(Product::class);
    }

    public function getCreatedAtAttribute($value)
    {
        if ($value) return $value;
        return $this->transaction_date;
    }

    public function scopeExpense($query)
    {
        return $query->whereType("expense");
    }

    public function scopeIncome($query)
    {
        return $query->whereType("income");
    }

    public function scopeFromDate($query, string|null $date)
    {
        if (!$date) {
            return $query;
        }
        return $query->where("transaction_date", ">=", Carbon::parse($date)->startOfDay());
    }

    public function scopeToDate($query, $date)
    {
        if (!$date) {
            return $query;
        }
        return $query->where("transaction_date", "<=", Carbon::parse($date)->endOfDay());
    }

    public function scopeForCategories($query, $categoriesId)
    {
        return $query->whereIn('expense_root_category_id', $categoriesId)
            ->orWhereIn('expense_secondary_category_id', $categoriesId)
            ->orWhereIn('expense_final_category_id', $categoriesId);
    }

    public function distribute(): Product
    {
        $company = $this->findOrCreateCompany();
        $product = $this->findOrCreateProduct();
        $this->product_id = $product->id;
        $this->company_id = $company->id;
        $this->save();
        $company->products()->syncWithoutDetaching([$product->id => ['price' => $this->price]]);
        $product->syncAllTransactions();
        return $product;
    }

    public function findOrCreateProduct(): Product
    {
        $product = Product::where("title", $this->title)->first();
        if (!$product) {
            $product = new Product([
                'title' => $this->title,
                'root_category_id' => $this->expense_root_category_id,
            ]);
            $product->save();
        }
        return $product;
    }

    public function findOrCreateCompany(): Company
    {
        $company = Company::query()->where("title", $this->company)->first();
        if (!$company) {
            $company = new Company(['title' => $this->company]);
            $company->save();
        }
        return $company;
    }
}
